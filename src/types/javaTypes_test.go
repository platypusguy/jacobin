/*
 * Jacobin VM - A Java virtual machine
 * Copyright (c) 2023-4 by Jacobin authors. All rights reserved.
 * Licensed under Mozilla Public License 2.0 (MPL 2.0)
 */

package types

import "testing"

// Test that the functions return the correct results
func TestTheIsFunctionsValidate(t *testing.T) {
	if !IsIntegral(Bool) {
		t.Errorf("IsIntegral() returned false for boolean, should be true")
	}

	if !IsIntegral(Char) {
		t.Errorf("IsIntegral() returned false for char, should be true")
	}

	if !IsIntegral(Short) {
		t.Errorf("IsIntegral() returned false for short, should be true")
	}

	if !IsAddress(ByteArray) {
		t.Errorf("IsAddress() returned false for byte array, should be true")
	}

	if !IsStatic("X[B") {
		t.Errorf("IsStatic() returned false for 'X[B', should be true")
	}

	if !IsFloatingPoint(Float) {
		t.Errorf("IsFloatingPoint() returned false for float, should be true")
	}

	if !IsFloatingPoint(Double) {
		t.Errorf("IsFloatingPoint() returned false for double, should be true")
	}

	if !IsError("0") {
		t.Errorf("IsError returned false for Error, should be true")
	}
}

// Test that the functions don't return invalid results
func TestTheIsFunctionsNegatively(t *testing.T) {
	if IsIntegral(Error) {
		t.Errorf("Error incorrectly was true in IsIntegral()")
	}

	if IsFloatingPoint(Bool) {
		t.Errorf("Error: Bool incorrectly is true in IsFloatingPoint()")
	}

	if IsAddress(Int) {
		t.Errorf("Error: Int incorrectly is true in IsAddress()")
	}

	if IsStatic(ByteArray) {
		t.Errorf("Error: ByteArray incorrectly is true in IsStatic()")
	}

	if IsError(Short) {
		t.Errorf("Error: Short is incorrectly true in IsError()")
	}
}

// Test the go-to-Java conversion of booleans
func TestJavaBoolean(t *testing.T) {

	val := ConvertGoBoolToJavaBool(true)
	if val != JavaBoolTrue {
		t.Errorf("JavaBool: expected a result of 1, but got: %d", val)
	}

	val = ConvertGoBoolToJavaBool(false)
	if val != JavaBoolFalse {
		t.Errorf("JavaBool: expected a result of 0, but got: %d", val)
	}
}

// Test typeUtils.go's FourBytesToInt64() function
func TestFourBytesToInt64(t *testing.T) {
	// Test a positive number
	val := FourBytesToInt64(0x00, 0x00, 0x00, 0x01)
	if val != 1 {
		t.Errorf("FourBytesToInt64: expected a result of 1, but got: %d", val)
	}

	// Test a negative number
	val = FourBytesToInt64(0xff, 0xff, 0xff, 0xff)
	if val != -1 {
		t.Errorf("FourBytesToInt64: expected a result of -1, but got: %d", val)
	}
}

// === The following tests were generated by JetBrains Junie to cover test gaps

func TestIsPrimitive(t *testing.T) {
	// Test positive cases - integral types
	if !IsPrimitive(Byte) {
		t.Errorf("IsPrimitive() returned false for Byte, should be true")
	}

	if !IsPrimitive(Char) {
		t.Errorf("IsPrimitive() returned false for Char, should be true")
	}

	if !IsPrimitive(Int) {
		t.Errorf("IsPrimitive() returned false for Int, should be true")
	}

	if !IsPrimitive(Long) {
		t.Errorf("IsPrimitive() returned false for Long, should be true")
	}

	if !IsPrimitive(Short) {
		t.Errorf("IsPrimitive() returned false for Short, should be true")
	}

	if !IsPrimitive(Bool) {
		t.Errorf("IsPrimitive() returned false for Bool, should be true")
	}

	// Test positive cases - floating point types
	if !IsPrimitive(Float) {
		t.Errorf("IsPrimitive() returned false for Float, should be true")
	}

	if !IsPrimitive(Double) {
		t.Errorf("IsPrimitive() returned false for Double, should be true")
	}
	// Removed as part of JACOBIN-720. We don't use runes internally. Reinstate if necessary and document the need.
	// // Test positive cases - Rune type
	// if !IsPrimitive(Rune) {
	// 	t.Errorf("IsPrimitive() returned false for Rune, should be true")
	// }

	// Test negative cases
	if IsPrimitive(Ref) {
		t.Errorf("IsPrimitive() returned true for Ref, should be false")
	}

	if IsPrimitive(Array) {
		t.Errorf("IsPrimitive() returned true for Array, should be false")
	}

	if IsPrimitive(Error) {
		t.Errorf("IsPrimitive() returned true for Error, should be false")
	}

	if IsPrimitive("unknown") {
		t.Errorf("IsPrimitive() returned true for unknown type, should be false")
	}
}

// Test IsArray function (completely untested)
func TestIsArray(t *testing.T) {
	// Test positive cases - single dimension arrays
	if !IsArray(BoolArray) {
		t.Errorf("IsArray() returned false for BoolArray, should be true")
	}

	if !IsArray(ByteArray) {
		t.Errorf("IsArray() returned false for ByteArray, should be true")
	}

	if !IsArray(CharArray) {
		t.Errorf("IsArray() returned false for CharArray, should be true")
	}

	if !IsArray(DoubleArray) {
		t.Errorf("IsArray() returned false for DoubleArray, should be true")
	}

	if !IsArray(IntArray) {
		t.Errorf("IsArray() returned false for IntArray, should be true")
	}

	if !IsArray(FloatArray) {
		t.Errorf("IsArray() returned false for FloatArray, should be true")
	}

	if !IsArray(LongArray) {
		t.Errorf("IsArray() returned false for LongArray, should be true")
	}

	if !IsArray(RefArray) {
		t.Errorf("IsArray() returned false for RefArray, should be true")
	}

	if !IsArray(RuneArray) {
		t.Errorf("IsArray() returned false for RuneArray, should be true")
	}

	if !IsArray(ShortArray) {
		t.Errorf("IsArray() returned false for ShortArray, should be true")
	}

	// Test positive cases - multi-dimensional arrays
	if !IsArray(MultiArray) {
		t.Errorf("IsArray() returned false for MultiArray, should be true")
	}

	if !IsArray("[[I") {
		t.Errorf("IsArray() returned false for 2D int array, should be true")
	}

	// Test edge case - just the Array prefix
	if !IsArray(Array) {
		t.Errorf("IsArray() returned false for Array prefix, should be true")
	}

	// Test negative cases
	if IsArray(Int) {
		t.Errorf("IsArray() returned true for Int, should be false")
	}

	if IsArray(Ref) {
		t.Errorf("IsArray() returned true for Ref, should be false")
	}

	if IsArray(Error) {
		t.Errorf("IsArray() returned true for Error, should be false")
	}

	if IsArray("") {
		t.Errorf("IsArray() returned true for empty string, should be false")
	}

	if IsArray("X[I") { // Static array but doesn't start with [
		t.Errorf("IsArray() returned true for static array notation, should be false")
	}
}

// Test additional IsAddress cases (Ref type not tested)
func TestIsAddressAdditional(t *testing.T) {
	// Test Ref type (not previously tested)
	if !IsAddress(Ref + "java/lang/String;") {
		t.Errorf("IsAddress() returned false for reference type, should be true")
	}

	if !IsAddress(Ref) {
		t.Errorf("IsAddress() returned false for Ref prefix, should be true")
	}

	// Test negative cases not previously covered
	if IsAddress(Bool) {
		t.Errorf("IsAddress() returned true for Bool, should be false")
	}

	if IsAddress(Double) {
		t.Errorf("IsAddress() returned true for Double, should be false")
	}

	if IsAddress(Float) {
		t.Errorf("IsAddress() returned true for Float, should be false")
	}

	if IsAddress(Long) {
		t.Errorf("IsAddress() returned true for Long, should be false")
	}

	if IsAddress(Rune) {
		t.Errorf("IsAddress() returned true for Rune, should be false")
	}

	if IsAddress("") {
		t.Errorf("IsAddress() returned true for empty string, should be false")
	}
}

// Test Int64ToBytesBE function (completely untested)
func TestInt64ToBytesBE(t *testing.T) {
	// Test positive number
	result := Int64ToBytesBE(1)
	expected := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
	if len(result) != len(expected) {
		t.Errorf("Int64ToBytesBE(1): expected length %d, got %d", len(expected), len(result))
	}
	for i, b := range expected {
		if i < len(result) && result[i] != b {
			t.Errorf("Int64ToBytesBE(1): expected byte %d to be 0x%02x, got 0x%02x", i, b, result[i])
		}
	}

	// Test zero
	result = Int64ToBytesBE(0)
	expected = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	if len(result) != len(expected) {
		t.Errorf("Int64ToBytesBE(0): expected length %d, got %d", len(expected), len(result))
	}
	for i, b := range expected {
		if i < len(result) && result[i] != b {
			t.Errorf("Int64ToBytesBE(0): expected byte %d to be 0x%02x, got 0x%02x", i, b, result[i])
		}
	}

	// Test negative number
	result = Int64ToBytesBE(-1)
	expected = []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
	if len(result) != len(expected) {
		t.Errorf("Int64ToBytesBE(-1): expected length %d, got %d", len(expected), len(result))
	}
	for i, b := range expected {
		if i < len(result) && result[i] != b {
			t.Errorf("Int64ToBytesBE(-1): expected byte %d to be 0x%02x, got 0x%02x", i, b, result[i])
		}
	}

	// Test large positive number
	result = Int64ToBytesBE(0x123456789ABCDEF0)
	expected = []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}
	if len(result) != len(expected) {
		t.Errorf("Int64ToBytesBE(large): expected length %d, got %d", len(expected), len(result))
	}
	for i, b := range expected {
		if i < len(result) && result[i] != b {
			t.Errorf("Int64ToBytesBE(large): expected byte %d to be 0x%02x, got 0x%02x", i, b, result[i])
		}
	}
}

// Test BytesToInt64BE function (completely untested)
func TestBytesToInt64BE(t *testing.T) {
	// Test single byte
	result := BytesToInt64BE([]byte{0x01})
	expected := int64(1)
	if result != expected {
		t.Errorf("BytesToInt64BE([0x01]): expected %d, got %d", expected, result)
	}

	// Test two bytes
	result = BytesToInt64BE([]byte{0x01, 0x02})
	expected = int64(3) // 1 + 2 = 3
	if result != expected {
		t.Errorf("BytesToInt64BE([0x01, 0x02]): expected %d, got %d", expected, result)
	}

	// Test multiple bytes
	result = BytesToInt64BE([]byte{0x10, 0x20, 0x30})
	expected = int64(0x10 + 0x20 + 0x30) // 16 + 32 + 48 = 96
	if result != expected {
		t.Errorf("BytesToInt64BE([0x10, 0x20, 0x30]): expected %d, got %d", expected, result)
	}

	// Test empty array
	result = BytesToInt64BE([]byte{})
	expected = int64(0)
	if result != expected {
		t.Errorf("BytesToInt64BE([]): expected %d, got %d", expected, result)
	}

	// Test all zeros
	result = BytesToInt64BE([]byte{0x00, 0x00, 0x00})
	expected = int64(0)
	if result != expected {
		t.Errorf("BytesToInt64BE([0x00, 0x00, 0x00]): expected %d, got %d", expected, result)
	}

	// Test high values
	result = BytesToInt64BE([]byte{0xFF, 0xFF})
	expected = int64(255 + 255) // 510
	if result != expected {
		t.Errorf("BytesToInt64BE([0xFF, 0xFF]): expected %d, got %d", expected, result)
	}
}

// Test additional IsIntegral cases (missing some types)
func TestIsIntegralAdditional(t *testing.T) {
	// Test types that weren't explicitly tested before
	if !IsIntegral(Byte) {
		t.Errorf("IsIntegral() returned false for Byte, should be true")
	}

	if !IsIntegral(Int) {
		t.Errorf("IsIntegral() returned false for Int, should be true")
	}

	if !IsIntegral(Long) {
		t.Errorf("IsIntegral() returned false for Long, should be true")
	}

	// Test negative cases not previously covered
	if IsIntegral(Float) {
		t.Errorf("IsIntegral() returned true for Float, should be false")
	}

	if IsIntegral(Double) {
		t.Errorf("IsIntegral() returned true for Double, should be false")
	}

	if IsIntegral(Rune) {
		t.Errorf("IsIntegral() returned true for Rune, should be false")
	}

	if IsIntegral(Ref) {
		t.Errorf("IsIntegral() returned true for Ref, should be false")
	}

	if IsIntegral("") {
		t.Errorf("IsIntegral() returned true for empty string, should be false")
	}
}

// Test IsStatic edge cases (additional coverage)
func TestIsStaticAdditional(t *testing.T) {
	// Test various Static type combinations
	if !IsStatic(StaticDouble) {
		t.Errorf("IsStatic() returned false for StaticDouble, should be true")
	}

	if !IsStatic(StaticLong) {
		t.Errorf("IsStatic() returned false for StaticLong, should be true")
	}

	if !IsStatic(Static) {
		t.Errorf("IsStatic() returned false for Static prefix, should be true")
	}

	// Test negative cases
	if !IsStatic("XS") { // doesn't start with X
		t.Errorf("IsStatic() returned false for 'XS', should be true")
	}

	if IsStatic("") {
		t.Errorf("IsStatic() returned true for empty string, should be false")
	}

	if IsStatic("Y" + Static) {
		t.Errorf("IsStatic() returned true for string containing but not starting with X, should be false")
	}
}

// Test IsError edge cases (additional coverage)
func TestIsErrorAdditional(t *testing.T) {
	// Test negative cases not previously covered
	if IsError("00") {
		t.Errorf("IsError() returned true for '00', should be false")
	}

	if IsError("") {
		t.Errorf("IsError() returned true for empty string, should be false")
	}

	if IsError("0X") {
		t.Errorf("IsError() returned true for '0X', should be false")
	}

	if IsError("X0") {
		t.Errorf("IsError() returned true for 'X0', should be false")
	}
}

// === end of Junie-generated tests ===
